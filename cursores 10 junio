
CREATE TABLE USUARIO1 (ID_USUARIO1 INTEGER,
 NOMBRE VARCHAR2(120),
 EMAIL VARCHAR2(90), SUELDO_BASE FLOAT,
CONSTRAINT ID_USUARIO1_PK PRIMARY KEY(ID_USUARIO1));

create sequence sec_usuario1
start with 1
increment by 1
nomaxvalue;

create or replace PROCEDURE GUARDAR_USUARIO1(
MY_ID_USUARIO1 OUT INTEGER, MY_NOMBRE IN VARCHAR2,
MY_EMAIL IN VARCHAR2, MY_SUELDO_BASE IN FLOAT)
AS
BEGIN 
SELECT SEC_USUARIO1.NEXTVAL INTO MY_ID_USUARIO1 FROM DUAL;
INSERT INTO USUARIO1 VALUES(MY_ID_USUARIO1, MY_NOMBRE,
MY_EMAIL, MY_SUELDO_BASE);
END;
/


DECLARE
  MY_ID INTEGER;
BEGIN
  GUARDAR_USUARIO1(MY_ID,'CHANA','CHANA@GMAIL.COM',6000);
  GUARDAR_USUARIO1(MY_ID,'PANCRACIO','PAN@GMAIL.COM',5000);
  GUARDAR_USUARIO1(MY_ID,'PETRONILA','PETRO@GMAIL.COM',8000);
END;
/
SELECT * FROM USUARIO1;
--Inicializaremos un bloque piel sequel

--Empezamos con los cursores en este ejemplo en el cual usamos un select especificando
-- que nos deba de mostrar 1D_USUARIO=1;
--lAS DESVENTAJAS SON QUE SOLO AGARRAN UNA LINEA , NO AGARRAN MAS DE 1 LINEA
SET SERVEROUTPUT ON;
--Para mostrarlo en modo de consola para ver las salidas dbms

DECLARE
ALGO VARCHAR2(120);
BEGIN
dbms_output.put_line('Probaremos un cursor implicito');
--Cursor implicito 

SELECT NOMBRE INTO ALGO FROM USUARIO1 WHERE ID_USUARIO1=1;
dbms_output.put_line('En la memoria global esta '|| ALGO);
END;
/

-- EL MISMO EJERCICIO CON CURSOR EXPLICITO PARA OBTENER MUCHAS FILAS O DATOS DE LA MEMORIA

DECLARE
-- Para declarar un cursor explicito utilizaremos CURSOR
CURSOR CUR_USUARIO1 IS SELECT * FROM USUARIO1;
BEGIN
--INTERALO LOCALMENTE ESTE SELECT
FOR REC_USUARIO IN CUR_USUARIO1 LOOP
DBMS_OUTPUT.PUT_LINE ('En este momento esta en memoria:' || REC_USUARIO.NOMBRE);
END LOOP;
END;
